{"version":3,"sources":["../src/getOpenAIBody.ts","../src/schemas.ts","../src/template.ts","../src/handlebars-helpers.ts"],"sourcesContent":["import type OpenAI from \"openai\"\nimport { z } from \"zod\"\nimport { extendZodWithOpenApi } from \"@asteasolutions/zod-to-openapi\"\n\nimport { MessageSchema, PlaygroundState } from \"./schemas\"\nimport { compileLTTemplate } from \"./template\"\n\nextendZodWithOpenApi(z)\n\nexport const bodyMetadataSchema = z\n  .record(z.string().max(64), z.union([z.string(), z.number()]))\n  .optional()\n\nexport const langtailBodySchema = z.object({\n  doNotRecord: z.boolean().optional().openapi({\n    description:\n      \"If true, potentially sensitive data like the prompt and response will not be recorded in the logs\",\n    example: false,\n  }),\n  metadata: bodyMetadataSchema,\n  _langtailTestRunId: z.string().optional(),\n  _langtailTestInputId: z.string().optional(),\n})\n\nexport const openAiBodySchema = z.object({\n  stream: z.boolean().optional().openapi({ example: false }),\n  user: z.string().optional().openapi({\n    description: \"A unique identifier representing your end-user\",\n    example: \"user_123\",\n  }),\n\n  seed: z.number().optional().openapi({\n    description: \"A seed is used  to generate reproducible results\",\n    example: 123,\n  }),\n\n  variables: z.record(z.string(), z.string()).optional(),\n\n  messages: z\n    .array(MessageSchema)\n    .optional()\n    .openapi({\n      description: \"Additional messages to seed the conversation with\",\n      example: [\n        {\n          role: \"user\",\n          content: \"Hello\",\n        },\n      ],\n    }),\n})\n\nexport const bothBodySchema = langtailBodySchema.merge(openAiBodySchema)\n\nexport type IncomingBodyType = z.infer<typeof bothBodySchema>\nexport type OpenAiBodyType = z.infer<typeof openAiBodySchema>\n\n// TODO remove this from our prompt-API when this is merged so that we don't have this code duplicated\nexport function getOpenAIBody(\n  completionConfig: PlaygroundState,\n  parsedBody: IncomingBodyType,\n) {\n  const completionArgs = completionConfig.state.args\n\n  const inputMessages = [\n    ...completionConfig.state.template.map((item) => {\n      const needsCompilation =\n        typeof item.content === \"string\" ? item.content?.includes(\"{{\") : true\n\n      return {\n        ...item,\n        content:\n          item.content &&\n          (needsCompilation\n            ? compileLTTemplate(\n                item.content,\n                parsedBody.variables as Record<string, string>,\n              )\n            : item.content),\n      }\n    }),\n    ...(parsedBody.messages ?? []),\n  ]\n  const openAIbody: OpenAI.Chat.ChatCompletionCreateParams = {\n    model: completionArgs.model,\n    max_tokens:\n      completionArgs.max_tokens == -1 ? undefined : completionArgs.max_tokens,\n    temperature: completionArgs.temperature,\n    // @ts-expect-error\n    messages: inputMessages,\n    top_p: completionArgs.top_p,\n    presence_penalty: completionArgs.presence_penalty,\n    frequency_penalty: completionArgs.frequency_penalty,\n    ...(completionArgs.jsonmode\n      ? {\n          response_format: {\n            type: \"json_object\",\n          },\n        }\n      : {}),\n    ...(parsedBody.seed || completionArgs.seed\n      ? {\n          seed: parsedBody.seed ?? completionArgs.seed,\n        }\n      : {}),\n    ...(Array.isArray(completionArgs.stop) && completionArgs.stop.length > 0\n      ? { stop: completionArgs.stop }\n      : {}),\n  }\n  if (\n    completionConfig.state.functions &&\n    completionConfig.state.functions.length > 0\n  ) {\n    openAIbody.functions = completionConfig.state.functions\n  }\n  if (completionConfig.state.tools && completionConfig.state.tools.length > 0) {\n    // Remove tools[0].function.id from the tools array as that is an internal langtail id\n    openAIbody.tools = completionConfig.state.tools.map((tool) => {\n      const { id: _, ...rest } = tool.function\n      return { ...tool, function: rest }\n    })\n  }\n  return openAIbody\n}\n\nexport type ChatCompletionCreateParams = OpenAI.Chat.ChatCompletionCreateParams\n","import { z } from \"zod\"\n\nexport interface ChatState {\n  type: \"chat\"\n  template: PlaygroundMessage[]\n  functions?: Functions[]\n  tools?: Tools[]\n  args: ModelParameter\n}\n\nexport type ModelParameter = {\n  model: string\n  temperature: number\n  max_tokens: number\n  top_p: number\n  stop?: string[]\n  presence_penalty: number\n  frequency_penalty: number\n  stream?: boolean\n  jsonmode?: boolean\n  seed?: number | null\n}\n\nexport interface Functions {\n  name: string\n  description: string\n  parameters: Record<string, unknown>\n  id?: string\n}\n\nexport interface Tools {\n  type: \"function\"\n  function: Functions\n}\n\nexport interface CompletionState {\n  type: \"completion\"\n  template: string\n  args: ModelParameter\n}\n\nexport interface ContentItemText {\n  type: \"text\"\n  text: string\n}\n\nexport interface ContentItemImage {\n  type: \"image_url\"\n  image_url: {\n    url: string\n    detail?: \"auto\" | \"low\" | \"high\"\n  }\n}\n\nexport type ContentArray = Array<ContentItemText | ContentItemImage>\n\nexport interface ToolCall {\n  id: string\n  type: \"function\"\n  function: {\n    name: string\n    arguments: string\n  }\n}\n\nexport interface Message {\n  role: \"assistant\" | \"user\" | \"system\" | \"function\" | \"tool\"\n  name?: string\n  content: string | ContentArray | null\n  function_call?: {\n    name: string\n    arguments: string\n  }\n  tool_calls?: ToolCall[]\n  tool_choice?:\n    | {\n        type: \"function\"\n        function: {\n          name: string\n        }\n      }\n    | \"auto\"\n    | \"none\"\n  tool_call_id?: string\n  // NOTE: dynamic property calculated by the client for the diff view\n  hash?: string\n}\n\nexport interface PlaygroundMessage extends Message {\n  pending?: boolean\n  error?: unknown\n}\n\nexport interface PlaygroundState {\n  state: ChatState\n  chatInput: Record<string, string>\n}\n\nexport const ContentItemTextSchema = z.object({\n  type: z.literal(\"text\"),\n  text: z.string(),\n}) satisfies z.ZodType<ContentItemText>\n\nexport const ContentItemImageSchema = z.object({\n  type: z.literal(\"image_url\"),\n  image_url: z.object({\n    url: z.string(),\n    detail: z.enum([\"auto\", \"low\", \"high\"]).default(\"auto\"),\n  }),\n}) satisfies z.ZodType<ContentItemImage>\n\nconst ContentArraySchema = z.array(\n  z.union([ContentItemTextSchema, ContentItemImageSchema]),\n) satisfies z.ZodType<ContentArray>\n\nconst FunctionCallSchema = z.object({\n  name: z.string(),\n  arguments: z.string(),\n})\n\nconst ToolCallSchema = z.object({\n  id: z.string(),\n  type: z.literal(\"function\"),\n  function: FunctionCallSchema,\n}) satisfies z.ZodType<ToolCall>\n\nconst ToolChoiceSchema = z.union([\n  z.literal(\"auto\"),\n  z.literal(\"none\"),\n  z.object({\n    type: z.literal(\"function\"),\n    function: z.object({\n      name: z.string(),\n    }),\n  }),\n])\n\nexport const MessageSchema = z.object({\n  role: z.union([\n    z.literal(\"assistant\"),\n    z.literal(\"user\"),\n    z.literal(\"system\"),\n    z.literal(\"function\"),\n    z.literal(\"tool\"),\n  ]),\n  name: z.string().optional(),\n  content: ContentArraySchema.or(z.string().nullable()),\n  function_call: FunctionCallSchema.optional(),\n  tool_calls: z.array(ToolCallSchema).optional(),\n  tool_choice: ToolChoiceSchema.optional(),\n  tool_call_id: z.string().optional(),\n}) satisfies z.ZodType<Message>\n","import handlebars from \"@langtail/handlebars-evalless\"\nimport { Visitor } from \"handlebars\"\n\nimport { handlebarsDateHelper, operatorHelpers } from \"./handlebars-helpers\"\nimport { JSONValue } from \"./jsonType\"\nimport { ContentArray } from \"./schemas\"\n\nhandlebars.registerHelper(\"$date\", handlebarsDateHelper)\nhandlebars.registerHelper(operatorHelpers)\n\n/*\n * This class is used to wrap the input object to be used in handlebars templates. Without this JSON objects are rendered as [object Object]\n */\nclass TemplateObject {\n  _value: any\n  constructor(props: any) {\n    this._value = props\n  }\n  toString() {\n    return JSON.stringify(this._value, null, 2)\n  }\n}\n\nfunction castToTemplateObject(value: any): any {\n  if (typeof value === \"object\" && value !== null) {\n    if (Array.isArray(value)) {\n      return value.map((item) => castToTemplateObject(item))\n    }\n    return new TemplateObject(value)\n  }\n  return value\n}\n\n// does not throw\nexport const compileStringHandlebars = (\n  text: string,\n  input: Record<string, JSONValue>,\n): {\n  text: string\n  error: Error | null\n} => {\n  try {\n    // Preprocess the template to improve readability and consistency. This involves:\n    // 1. Removing newline characters before and after the {{else}} block.\n    // 2. Removing newline characters before closing block helpers (like '/if', '/unless', '/with').\n    const preprocessedText = text\n      .replace(/\\n?({{else}})\\n?/g, \"$1\") // Remove newline before and after {{else}}\n      .replace(/\\n({{\\/(if|unless|with)}})/g, \"$1\") // Remove newline before closing block helpers\n\n    const template = handlebars.compileAST(preprocessedText, { noEscape: true }) // regular compile cannot be used in cloudflare worker\n\n    const parsedInput: Record<string, JSONValue | TemplateObject> = {}\n    for (const key in input) {\n      try {\n        const parsed = JSON.parse(input[key] as string)\n\n        if (typeof parsed === \"object\" && parsed !== null) {\n          if (Array.isArray(parsed)) {\n            parsedInput[key] = parsed.map((item) => castToTemplateObject(item))\n          } else {\n            parsedInput[key] = new TemplateObject(parsed)\n          }\n        } else {\n          parsedInput[key] = input[key]\n        }\n      } catch {\n        parsedInput[key] = input[key]\n      }\n    }\n\n    const handlebarsOutput = template(parsedInput).replace(/\\n$/g, \"\") // Remove trailing newline,\n    return {\n      text: handlebarsOutput, // ideally we would not even encode it, but in handlebars HTML entities encoding cannot be turned off. We could only use triple curly braces\n      error: null,\n    }\n  } catch (err: any) {\n    return { text, error: err }\n  }\n}\n\nexport const compileLTTemplate = (\n  content: string | ContentArray | null,\n  input: Record<string, string>,\n) => {\n  if (content === null) {\n    return null\n  }\n\n  if (typeof content === \"string\") {\n    return compileStringHandlebars(content, input).text\n  }\n\n  return content.map((item) => {\n    if (item.type === \"text\") {\n      return { ...item, text: compileStringHandlebars(item.text, input).text }\n    }\n    return item\n  })\n}\n\ninterface PathExpression {\n  original: string\n}\n\nclass VariableScanner extends Visitor {\n  variables: string[]\n  builtInHelpers: Set<string>\n  withStack: boolean[] // Track 'with' blocks depth\n  eachStack: boolean[] // Track 'each' blocks depth\n  currentBlockParams: Set<string> // Track block params for 'each' blocks\n\n  constructor() {\n    super()\n    this.variables = []\n    this.builtInHelpers = new Set([\n      \"if\",\n      \"each\",\n      \"unless\",\n      \"with\",\n      \"log\",\n      \"lookup\",\n      \"this\",\n      \"blockHelperMissing\",\n      \"helperMissing\",\n      \"raw\",\n      \"eq\",\n      \"ne\",\n      \"lt\",\n      \"gt\",\n      \"lte\",\n      \"gte\",\n      \"and\",\n      \"or\",\n      \"@key\",\n      \"@index\",\n      \"$date\",\n    ])\n    this.withStack = []\n    this.eachStack = []\n    this.currentBlockParams = new Set()\n  }\n\n  BlockStatement(block: any): void {\n    // Check for 'with' and 'each' blocks\n    const isWithBlock = block.path.original === \"with\"\n    const isEachBlock = block.path.original === \"each\"\n\n    if (isWithBlock) {\n      this.withStack.push(true)\n      if (\n        block.params[0] &&\n        !this.builtInHelpers.has(block.params[0].original)\n      ) {\n        this.variables.push(block.params[0].original)\n      }\n    }\n\n    if (isEachBlock) {\n      this.eachStack.push(true) // Indicate we're inside an 'each' block\n      if (block.program.blockParams?.length > 0) {\n        block.program.blockParams.forEach((param: any) =>\n          this.currentBlockParams.add(param),\n        )\n      }\n    }\n\n    // Process the block's content\n    super.BlockStatement(block)\n\n    if (isWithBlock) {\n      this.withStack.pop()\n    }\n\n    if (isEachBlock) {\n      this.eachStack.pop() // Exiting the 'each' block\n      if (block.program.blockParams?.length > 0) {\n        block.program.blockParams.forEach((param: any) =>\n          this.currentBlockParams.delete(param),\n        )\n      }\n    }\n  }\n\n  PathExpression(path: PathExpression): void {\n    const isInsideWith = this.withStack.length > 0\n    const isInsideEach = this.eachStack.length > 0\n    const rootVariable = path.original?.split(\".\")[0] ?? \"\"\n    const isBlockParam = this.currentBlockParams.has(rootVariable)\n    const isThisProperty = path.original.startsWith(\"this.\")\n\n    if (\n      !isInsideWith &&\n      !(isInsideEach && isThisProperty) && // Correctly ignore 'this.' prefixed variables inside 'each' blocks\n      !isBlockParam &&\n      !this.builtInHelpers.has(path.original)\n    ) {\n      this.variables.push(rootVariable) // Push rootVariable instead if you want to collect the base name\n    }\n  }\n}\n\nexport function extractVariablesForHandlebars(template: string): string[] {\n  try {\n    const ast = handlebars.parse(template)\n    const scanner = new VariableScanner()\n    scanner.accept(ast)\n    return scanner.variables\n  } catch (error) {\n    return []\n  }\n}\n","import type handlebars from \"@langtail/handlebars-evalless\"\nimport { format, parseISO } from \"date-fns\"\n\nconst isObject = function (val: any) {\n  return typeof val === \"object\"\n}\n\nconst isOptions = function (val: any) {\n  return isObject(val) && isObject(val.hash)\n}\nexport const defaultDateFormat = \"MMMM dd, yyyy\"\n\nconst formatDateSafe = function (date: Date, pattern: string) {\n  try {\n    return format(date, pattern)\n  } catch (e) {\n    return \"\"\n  }\n}\n\nexport function handlebarsDateHelper(\n  str: string | number | Date | null,\n  pattern: any,\n  options: any\n) {\n  if (isOptions(pattern)) {\n    options = pattern\n    pattern = null\n  }\n\n  if (isOptions(str)) {\n    options = str\n    pattern = null\n    str = null\n  }\n\n  // if no args are passed, return a formatted date\n  if (str == null && pattern == null) {\n    return formatDateSafe(new Date(), defaultDateFormat)\n  }\n\n  const date = str instanceof Date ? str : new Date(str as string | number)\n\n  // if both args are strings, this could apply to either lib.\n  if (typeof str === \"string\" && typeof pattern === \"string\") {\n    return formatDateSafe(parseISO(str), pattern)\n  }\n\n  // if only a string is passed, assume it's a date pattern ('YYYY')\n  if (typeof str === \"string\" && !pattern) {\n    return formatDateSafe(new Date(), str)\n  }\n\n  return formatDateSafe(date, pattern)\n}\n\nexport const operatorHelpers: handlebars.HelperDeclareSpec = {\n  eq: (v1, v2) => v1 == v2,\n  ne: (v1, v2) => v1 != v2,\n  lt: (v1, v2) => v1 < v2,\n  gt: (v1, v2) => v1 > v2,\n  lte: (v1, v2) => v1 <= v2,\n  gte: (v1, v2) => v1 >= v2,\n  and() {\n    return Array.prototype.every.call(arguments, Boolean)\n  },\n  or() {\n    return Array.prototype.slice.call(arguments, 0, -1).some(Boolean)\n  },\n}\n"],"mappings":"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","names":["import_zod","handlebars"]}