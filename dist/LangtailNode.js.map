{"version":3,"sources":["../src/LangtailNode.ts","../src/LangtailPrompts.ts","../package.json","../src/userAgent.ts","../src/getOpenAIBody.ts","../src/schemas.ts","../src/template.ts","../src/handlebars-helpers.ts"],"sourcesContent":["import OpenAI from \"openai\"\nimport * as Core from \"openai/core\"\nimport { LangtailPrompts } from \"./LangtailPrompts\"\nimport {\n  ChatCompletionCreateParamsStreaming,\n  Completions,\n} from \"openai/resources/index\"\nimport {\n  ChatCompletion,\n  ChatCompletionChunk,\n  ChatCompletionCreateParams,\n  ChatCompletionCreateParamsBase,\n  ChatCompletionCreateParamsNonStreaming,\n} from \"openai/resources/chat/completions\"\nimport { APIPromise } from \"openai/core\"\nimport { Stream } from \"openai/src/streaming\"\nimport { userAgent } from \"./userAgent\"\n\n\nexport const baseURL = \"https://proxy.langtail.com/v1\"\n\nexport interface ILangtailExtraProps {\n  doNotRecord?: boolean\n  metadata?: Record<string, any>\n}\n\nexport class LangtailNode {\n  prompts: LangtailPrompts\n  chat: {\n    completions: {\n      create(\n        body: ChatCompletionCreateParamsNonStreaming & ILangtailExtraProps,\n        options?: Core.RequestOptions,\n      ): APIPromise<ChatCompletion>\n      create(\n        body: ChatCompletionCreateParamsStreaming & ILangtailExtraProps,\n        options?: Core.RequestOptions,\n      ): APIPromise<Stream<ChatCompletionChunk>>\n      create(\n        body: ChatCompletionCreateParamsBase & ILangtailExtraProps,\n        options?: Core.RequestOptions,\n      ): APIPromise<Stream<ChatCompletionChunk> | ChatCompletion>\n      create(\n        body: ChatCompletionCreateParams & ILangtailExtraProps,\n        options?: Core.RequestOptions,\n      ): APIPromise<ChatCompletion> | APIPromise<Stream<ChatCompletionChunk>>\n    }\n  }\n\n  private _open_ai: OpenAI\n\n  constructor(options?: {\n    apiKey: string\n    baseURL?: string\n    doNotRecord?: boolean\n    organization?: string\n    project?: string\n    fetch?: Core.Fetch\n  }) {\n    const organization = options?.organization\n\n    const apiKey = options?.apiKey || process.env.LANGTAIL_API_KEY\n    if (!apiKey) {\n      throw new Error(\n        \"apiKey is required. You can pass it as an option or set the LANGTAIL_API_KEY environment variable.\",\n      )\n    }\n    const optionsToPass = {\n      baseURL: baseURL,\n      apiKey,\n      fetch: options?.fetch,\n    }\n\n    const defaultHeaders: Record<string, string> = {}\n    if (options?.doNotRecord) {\n      defaultHeaders[\"x-langtail-do-not-record\"] = \"true\"\n    }\n    this._open_ai = new OpenAI({\n      defaultHeaders: {\n        ...defaultHeaders,\n        \"x-langtail-organization\": organization,\n      },\n      ...optionsToPass,\n    })\n\n    this.prompts = new LangtailPrompts({\n      apiKey,\n      workspace: options?.organization,\n      project: options?.project,\n    })\n\n    this.chat = {\n      completions: {\n        // @ts-expect-error\n        create: (\n          params: ChatCompletionCreateParamsBase & ILangtailExtraProps,\n          options: Core.RequestOptions = {},\n        ) => {\n          if (params.doNotRecord) {\n            options.headers = {\n              [\"x-langtail-do-not-record\"]: \"true\",\n              'user-agent': userAgent,\n              ...options?.headers,\n            }\n          }\n          delete params.doNotRecord // openAI does not support these parameters\n\n          if (params.metadata) {\n            const metadataHeaders = Object.entries(params.metadata).reduce(\n              (acc, [key, value]) => {\n                acc[`x-langtail-metadata-${key}`] = value\n                return acc\n              },\n              {},\n            )\n            options.headers = {\n              ...metadataHeaders,\n              ...options?.headers,\n            }\n          }\n          delete params.metadata\n\n          return this._open_ai.chat.completions.create(params, options)\n        },\n      },\n    }\n\n    return this\n  }\n}\n\nexport { LangtailNode as Langtail }\nexport { LangtailPrompts as LangtailPrompts }\n","import {\n  ChatCompletion,\n  ChatCompletionAssistantMessageParam,\n} from \"openai/resources/chat/completions\"\nimport { ChatCompletionChunk } from \"openai/resources/chat/completions\"\n\nimport { Stream } from \"openai/streaming\"\nimport { ILangtailExtraProps } from \"./LangtailNode\"\nimport { Fetch } from \"openai/core\"\nimport { userAgent } from \"./userAgent\"\nimport queryString from \"query-string\"\nimport { PlaygroundState } from \"./schemas\"\nimport { OpenAiBodyType, getOpenAIBody } from \"./getOpenAIBody\"\n\nexport type Environment = \"preview\" | \"staging\" | \"production\"\n\ninterface LangtailPromptVariables {} // TODO use this when generating schema for deployed prompts\n\ntype StreamResponseType = Stream<ChatCompletionChunk>\n\ntype OpenAIResponseWithHttp = ChatCompletion & {\n  httpResponse: Response | globalThis.Response\n}\n\ntype Options = {\n  apiKey: string\n  baseURL?: string | undefined\n  workspace?: string | undefined\n  project?: string | undefined\n  fetch?: Fetch\n}\n\ninterface IRequestParams extends ILangtailExtraProps {\n  prompt: string\n  environment?: Environment\n  version?: string\n  variables?: Record<string, any>\n  messages?: ChatCompletionAssistantMessageParam[]\n}\n\ninterface IRequestParamsStream extends IRequestParams {\n  stream: boolean\n}\n\nexport class LangtailPrompts {\n  apiKey: string\n  baseUrl: string\n  options: Options\n\n  constructor(options: Options) {\n    const { apiKey, baseURL: baseUrl } = options\n    this.apiKey = apiKey\n    this.baseUrl = baseUrl ?? \"https://api.langtail.com\"\n    this.options = options\n  }\n\n  _createPromptPath({\n    prompt,\n    environment,\n    version,\n    configGet,\n  }: {\n    prompt: string\n    environment: Environment\n    version?: string\n    configGet?: boolean\n  }) {\n    if (prompt.includes(\"/\")) {\n      throw new Error(\n        \"prompt should not include / character, either omit workspace/project or use just the prompt name.\",\n      )\n    }\n    const queryParams = queryString.stringify({\n      v: version,\n      \"open-ai-completion-config-payload\": configGet,\n    })\n\n    if (this.options.workspace && this.options.project) {\n      const url = `${this.baseUrl}/${this.options.workspace}/${this.options.project}/${prompt}/${environment}?${queryParams}`\n      // user supplied workspace and project in constructor\n\n      return url\n    }\n\n    if (this.options.project) {\n      return `${this.options.project}/${prompt}/${environment}?${queryParams}`\n    }\n\n    const urlPath = `project-prompt/${prompt}/${environment}`\n    return urlPath.startsWith(\"/\")\n      ? this.baseUrl + urlPath + `?${queryParams}`\n      : `${this.baseUrl}/${urlPath}?${queryParams}`\n  }\n\n  invoke(options: IRequestParams): Promise<OpenAIResponseWithHttp>\n\n  invoke(options: IRequestParamsStream): Promise<StreamResponseType>\n  async invoke({\n    prompt,\n    environment,\n    doNotRecord,\n    metadata,\n    ...rest\n  }: IRequestParams | IRequestParamsStream) {\n    const metadataHeaders = metadata\n      ? Object.entries(metadata).reduce((acc, [key, value]) => {\n          acc[`x-langtail-metadata-${key}`] = value\n          return acc\n        }, {})\n      : {}\n\n    const fetchInit = {\n      method: \"POST\",\n      headers: {\n        \"X-API-Key\": this.apiKey,\n        \"user-agent\": userAgent,\n        \"content-type\": \"application/json\",\n        \"x-langtail-do-not-record\": doNotRecord ? \"true\" : \"false\",\n        ...metadataHeaders,\n      },\n      body: JSON.stringify({ stream: false, ...rest }),\n    }\n    const promptPath = this._createPromptPath({\n      prompt,\n      environment: environment ?? \"production\",\n      version: rest.version,\n    })\n\n    let res: Response | globalThis.Response\n\n    if (this.options.fetch) {\n      res = await this.options.fetch(promptPath, fetchInit)\n    } else {\n      res = await fetch(promptPath, fetchInit)\n    }\n\n    if (!res.ok) {\n      throw new Error(\n        `Failed to fetch prompt: ${res.status} ${await res.text()}`,\n      )\n    }\n\n    if (\"stream\" in rest && rest.stream) {\n      if (!res.body) {\n        throw new Error(\"No body in response\")\n      }\n      return Stream.fromSSEResponse(res, new AbortController())\n    }\n\n    const result = (await res.json()) as OpenAIResponseWithHttp\n    result.httpResponse = res\n    return result\n  }\n\n  async get({\n    prompt,\n    environment,\n    version,\n  }: {\n    prompt: string\n    environment: Environment\n    version?: string\n  }): Promise<PlaygroundState> {\n    const promptPath = this._createPromptPath({ prompt, environment, version })\n\n    const res = await fetch(promptPath, {\n      headers: {\n        \"X-API-Key\": this.apiKey,\n        \"user-agent\": userAgent,\n        \"content-type\": \"application/json\",\n      },\n    })\n\n    if (!res.ok) {\n      throw new Error(\n        `Failed to fetch prompt config payload: ${res.status} ${await res.text()}`,\n      )\n    }\n\n    return res.json()\n  }\n\n  build(completionConfig: PlaygroundState, parsedBody: OpenAiBodyType) {\n    return getOpenAIBody(completionConfig, parsedBody)\n  }\n}\n","{\n  \"name\": \"langtail\",\n  \"version\": \"0.2.2\",\n  \"description\": \"\",\n  \"main\": \"./dist/LangtailNode.js\",\n  \"packageManager\": \"pnpm@8.15.6\",\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"ts\": \"tsc --noEmit\",\n    \"format\": \"prettier --write .\",\n    \"build\": \"tsup\",\n    \"prepublishOnly\": \"pnpm run build\"\n  },\n  \"keywords\": [\n    \"openai\",\n    \"langtail\",\n    \"nlp\",\n    \"ai\",\n    \"natural language processing\",\n    \"gpt-3\",\n    \"gpt-4\",\n    \"anthropic\"\n  ],\n  \"authors\": [\n    \"Langtail <hi@langtail.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@types/node\": \"^20.12.7\",\n    \"dotenv\": \"^16.4.5\",\n    \"nock\": \"14.0.0-beta.5\",\n    \"prettier\": \"^3.2.5\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.4.5\",\n    \"vitest\": \"^1.5.0\"\n  },\n  \"module\": \"./dist/LangtailNode.mjs\",\n  \"types\": \"./dist/LangtailNode.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/LangtailNode.js\",\n      \"import\": \"./dist/LangtailNode.mjs\",\n      \"types\": \"./dist/LangtailNode.d.ts\"\n    }\n  },\n  \"files\": [\n    \"dist\",\n    \"src\"\n  ],\n  \"dependencies\": {\n    \"@asteasolutions/zod-to-openapi\": \"^7.0.0\",\n    \"@langtail/handlebars-evalless\": \"^0.0.1\",\n    \"date-fns\": \"^3.6.0\",\n    \"handlebars\": \"^4.7.8\",\n    \"openai\": \"^4.38.3\",\n    \"query-string\": \"^9.0.0\",\n    \"zod\": \"^3.23.4\"\n  },\n  \"tsup\": {\n    \"dts\": true,\n    \"sourcemap\": true,\n    \"format\": [\n      \"cjs\",\n      \"esm\"\n    ],\n    \"clean\": true,\n    \"entryPoints\": [\n      \"src/LangtailNode.ts\",\n      \"src/template.ts\",\n      \"src/getOpenAIBody.ts\"\n    ]\n  }\n}\n","import packageJson from \"../package.json\"\n\nexport const userAgent = `langtail-js-sdk:${packageJson.version}`","import type OpenAI from \"openai\"\nimport { z } from \"zod\"\nimport { extendZodWithOpenApi } from \"@asteasolutions/zod-to-openapi\"\n\nimport { MessageSchema, PlaygroundState } from \"./schemas\"\nimport { compileLTTemplate } from \"./template\"\n\nextendZodWithOpenApi(z)\n\nexport const bodyMetadataSchema = z\n  .record(z.string().max(64), z.union([z.string(), z.number()]))\n  .optional()\n\nexport const langtailBodySchema = z.object({\n  doNotRecord: z.boolean().optional().openapi({\n    description:\n      \"If true, potentially sensitive data like the prompt and response will not be recorded in the logs\",\n    example: false,\n  }),\n  metadata: bodyMetadataSchema,\n  _langtailTestRunId: z.string().optional(),\n  _langtailTestInputId: z.string().optional(),\n})\n\nexport const openAiBodySchema = z.object({\n  stream: z.boolean().optional().openapi({ example: false }),\n  user: z.string().optional().openapi({\n    description: \"A unique identifier representing your end-user\",\n    example: \"user_123\",\n  }),\n\n  seed: z.number().optional().openapi({\n    description: \"A seed is used  to generate reproducible results\",\n    example: 123,\n  }),\n\n  variables: z.record(z.string(), z.string()).optional(),\n\n  messages: z\n    .array(MessageSchema)\n    .optional()\n    .openapi({\n      description: \"Additional messages to seed the conversation with\",\n      example: [\n        {\n          role: \"user\",\n          content: \"Hello\",\n        },\n      ],\n    }),\n})\n\nexport const bothBodySchema = langtailBodySchema.merge(openAiBodySchema)\n\nexport type IncomingBodyType = z.infer<typeof bothBodySchema>\nexport type OpenAiBodyType = z.infer<typeof openAiBodySchema>\n\n// TODO remove this from our prompt-API when this is merged so that we don't have this code duplicated\nexport function getOpenAIBody(\n  completionConfig: PlaygroundState,\n  parsedBody: IncomingBodyType,\n) {\n  const completionArgs = completionConfig.state.args\n\n  const inputMessages = [\n    ...completionConfig.state.template.map((item) => {\n      const needsCompilation =\n        typeof item.content === \"string\" ? item.content?.includes(\"{{\") : true\n\n      return {\n        ...item,\n        content:\n          item.content &&\n          (needsCompilation\n            ? compileLTTemplate(\n                item.content,\n                parsedBody.variables as Record<string, string>,\n              )\n            : item.content),\n      }\n    }),\n    ...(parsedBody.messages ?? []),\n  ]\n  const openAIbody: OpenAI.Chat.ChatCompletionCreateParams = {\n    model: completionArgs.model,\n    max_tokens:\n      completionArgs.max_tokens == -1 ? undefined : completionArgs.max_tokens,\n    temperature: completionArgs.temperature,\n    // @ts-expect-error\n    messages: inputMessages,\n    top_p: completionArgs.top_p,\n    presence_penalty: completionArgs.presence_penalty,\n    frequency_penalty: completionArgs.frequency_penalty,\n    ...(completionArgs.jsonmode\n      ? {\n          response_format: {\n            type: \"json_object\",\n          },\n        }\n      : {}),\n    ...(parsedBody.seed || completionArgs.seed\n      ? {\n          seed: parsedBody.seed ?? completionArgs.seed,\n        }\n      : {}),\n    ...(Array.isArray(completionArgs.stop) && completionArgs.stop.length > 0\n      ? { stop: completionArgs.stop }\n      : {}),\n  }\n  if (\n    completionConfig.state.functions &&\n    completionConfig.state.functions.length > 0\n  ) {\n    openAIbody.functions = completionConfig.state.functions\n  }\n  if (completionConfig.state.tools && completionConfig.state.tools.length > 0) {\n    // Remove tools[0].function.id from the tools array as that is an internal langtail id\n    openAIbody.tools = completionConfig.state.tools.map((tool) => {\n      const { id: _, ...rest } = tool.function\n      return { ...tool, function: rest }\n    })\n  }\n  return openAIbody\n}\n\nexport type ChatCompletionCreateParams = OpenAI.Chat.ChatCompletionCreateParams\n","import { z } from \"zod\"\n\nexport interface ChatState {\n  type: \"chat\"\n  template: PlaygroundMessage[]\n  functions?: Functions[]\n  tools?: Tools[]\n  args: ModelParameter\n}\n\nexport type ModelParameter = {\n  model: string\n  temperature: number\n  max_tokens: number\n  top_p: number\n  stop?: string[]\n  presence_penalty: number\n  frequency_penalty: number\n  stream?: boolean\n  jsonmode?: boolean\n  seed?: number | null\n}\n\nexport interface Functions {\n  name: string\n  description: string\n  parameters: Record<string, unknown>\n  id?: string\n}\n\nexport interface Tools {\n  type: \"function\"\n  function: Functions\n}\n\nexport interface CompletionState {\n  type: \"completion\"\n  template: string\n  args: ModelParameter\n}\n\nexport interface ContentItemText {\n  type: \"text\"\n  text: string\n}\n\nexport interface ContentItemImage {\n  type: \"image_url\"\n  image_url: {\n    url: string\n    detail?: \"auto\" | \"low\" | \"high\"\n  }\n}\n\nexport type ContentArray = Array<ContentItemText | ContentItemImage>\n\nexport interface ToolCall {\n  id: string\n  type: \"function\"\n  function: {\n    name: string\n    arguments: string\n  }\n}\n\nexport interface Message {\n  role: \"assistant\" | \"user\" | \"system\" | \"function\" | \"tool\"\n  name?: string\n  content: string | ContentArray | null\n  function_call?: {\n    name: string\n    arguments: string\n  }\n  tool_calls?: ToolCall[]\n  tool_choice?:\n    | {\n        type: \"function\"\n        function: {\n          name: string\n        }\n      }\n    | \"auto\"\n    | \"none\"\n  tool_call_id?: string\n  // NOTE: dynamic property calculated by the client for the diff view\n  hash?: string\n}\n\nexport interface PlaygroundMessage extends Message {\n  pending?: boolean\n  error?: unknown\n}\n\nexport interface PlaygroundState {\n  state: ChatState\n  chatInput: Record<string, string>\n}\n\nexport const ContentItemTextSchema = z.object({\n  type: z.literal(\"text\"),\n  text: z.string(),\n}) satisfies z.ZodType<ContentItemText>\n\nexport const ContentItemImageSchema = z.object({\n  type: z.literal(\"image_url\"),\n  image_url: z.object({\n    url: z.string(),\n    detail: z.enum([\"auto\", \"low\", \"high\"]).default(\"auto\"),\n  }),\n}) satisfies z.ZodType<ContentItemImage>\n\nconst ContentArraySchema = z.array(\n  z.union([ContentItemTextSchema, ContentItemImageSchema]),\n) satisfies z.ZodType<ContentArray>\n\nconst FunctionCallSchema = z.object({\n  name: z.string(),\n  arguments: z.string(),\n})\n\nconst ToolCallSchema = z.object({\n  id: z.string(),\n  type: z.literal(\"function\"),\n  function: FunctionCallSchema,\n}) satisfies z.ZodType<ToolCall>\n\nconst ToolChoiceSchema = z.union([\n  z.literal(\"auto\"),\n  z.literal(\"none\"),\n  z.object({\n    type: z.literal(\"function\"),\n    function: z.object({\n      name: z.string(),\n    }),\n  }),\n])\n\nexport const MessageSchema = z.object({\n  role: z.union([\n    z.literal(\"assistant\"),\n    z.literal(\"user\"),\n    z.literal(\"system\"),\n    z.literal(\"function\"),\n    z.literal(\"tool\"),\n  ]),\n  name: z.string().optional(),\n  content: ContentArraySchema.or(z.string().nullable()),\n  function_call: FunctionCallSchema.optional(),\n  tool_calls: z.array(ToolCallSchema).optional(),\n  tool_choice: ToolChoiceSchema.optional(),\n  tool_call_id: z.string().optional(),\n}) satisfies z.ZodType<Message>\n","import handlebars from \"@langtail/handlebars-evalless\"\nimport { Visitor } from \"handlebars\"\n\nimport { handlebarsDateHelper, operatorHelpers } from \"./handlebars-helpers\"\nimport { JSONValue } from \"./jsonType\"\nimport { ContentArray } from \"./schemas\"\n\nhandlebars.registerHelper(\"$date\", handlebarsDateHelper)\nhandlebars.registerHelper(operatorHelpers)\n\n/*\n * This class is used to wrap the input object to be used in handlebars templates. Without this JSON objects are rendered as [object Object]\n */\nclass TemplateObject {\n  _value: any\n  constructor(props: any) {\n    this._value = props\n  }\n  toString() {\n    return JSON.stringify(this._value, null, 2)\n  }\n}\n\nfunction castToTemplateObject(value: any): any {\n  if (typeof value === \"object\" && value !== null) {\n    if (Array.isArray(value)) {\n      return value.map((item) => castToTemplateObject(item))\n    }\n    return new TemplateObject(value)\n  }\n  return value\n}\n\n// does not throw\nexport const compileStringHandlebars = (\n  text: string,\n  input: Record<string, JSONValue>,\n): {\n  text: string\n  error: Error | null\n} => {\n  try {\n    // Preprocess the template to improve readability and consistency. This involves:\n    // 1. Removing newline characters before and after the {{else}} block.\n    // 2. Removing newline characters before closing block helpers (like '/if', '/unless', '/with').\n    const preprocessedText = text\n      .replace(/\\n?({{else}})\\n?/g, \"$1\") // Remove newline before and after {{else}}\n      .replace(/\\n({{\\/(if|unless|with)}})/g, \"$1\") // Remove newline before closing block helpers\n\n    const template = handlebars.compileAST(preprocessedText, { noEscape: true }) // regular compile cannot be used in cloudflare worker\n\n    const parsedInput: Record<string, JSONValue | TemplateObject> = {}\n    for (const key in input) {\n      try {\n        const parsed = JSON.parse(input[key] as string)\n\n        if (typeof parsed === \"object\" && parsed !== null) {\n          if (Array.isArray(parsed)) {\n            parsedInput[key] = parsed.map((item) => castToTemplateObject(item))\n          } else {\n            parsedInput[key] = new TemplateObject(parsed)\n          }\n        } else {\n          parsedInput[key] = input[key]\n        }\n      } catch {\n        parsedInput[key] = input[key]\n      }\n    }\n\n    const handlebarsOutput = template(parsedInput).replace(/\\n$/g, \"\") // Remove trailing newline,\n    return {\n      text: handlebarsOutput, // ideally we would not even encode it, but in handlebars HTML entities encoding cannot be turned off. We could only use triple curly braces\n      error: null,\n    }\n  } catch (err: any) {\n    return { text, error: err }\n  }\n}\n\nexport const compileLTTemplate = (\n  content: string | ContentArray | null,\n  input: Record<string, string>,\n) => {\n  if (content === null) {\n    return null\n  }\n\n  if (typeof content === \"string\") {\n    return compileStringHandlebars(content, input).text\n  }\n\n  return content.map((item) => {\n    if (item.type === \"text\") {\n      return { ...item, text: compileStringHandlebars(item.text, input).text }\n    }\n    return item\n  })\n}\n\ninterface PathExpression {\n  original: string\n}\n\nclass VariableScanner extends Visitor {\n  variables: string[]\n  builtInHelpers: Set<string>\n  withStack: boolean[] // Track 'with' blocks depth\n  eachStack: boolean[] // Track 'each' blocks depth\n  currentBlockParams: Set<string> // Track block params for 'each' blocks\n\n  constructor() {\n    super()\n    this.variables = []\n    this.builtInHelpers = new Set([\n      \"if\",\n      \"each\",\n      \"unless\",\n      \"with\",\n      \"log\",\n      \"lookup\",\n      \"this\",\n      \"blockHelperMissing\",\n      \"helperMissing\",\n      \"raw\",\n      \"eq\",\n      \"ne\",\n      \"lt\",\n      \"gt\",\n      \"lte\",\n      \"gte\",\n      \"and\",\n      \"or\",\n      \"@key\",\n      \"@index\",\n      \"$date\",\n    ])\n    this.withStack = []\n    this.eachStack = []\n    this.currentBlockParams = new Set()\n  }\n\n  BlockStatement(block: any): void {\n    // Check for 'with' and 'each' blocks\n    const isWithBlock = block.path.original === \"with\"\n    const isEachBlock = block.path.original === \"each\"\n\n    if (isWithBlock) {\n      this.withStack.push(true)\n      if (\n        block.params[0] &&\n        !this.builtInHelpers.has(block.params[0].original)\n      ) {\n        this.variables.push(block.params[0].original)\n      }\n    }\n\n    if (isEachBlock) {\n      this.eachStack.push(true) // Indicate we're inside an 'each' block\n      if (block.program.blockParams?.length > 0) {\n        block.program.blockParams.forEach((param: any) =>\n          this.currentBlockParams.add(param),\n        )\n      }\n    }\n\n    // Process the block's content\n    super.BlockStatement(block)\n\n    if (isWithBlock) {\n      this.withStack.pop()\n    }\n\n    if (isEachBlock) {\n      this.eachStack.pop() // Exiting the 'each' block\n      if (block.program.blockParams?.length > 0) {\n        block.program.blockParams.forEach((param: any) =>\n          this.currentBlockParams.delete(param),\n        )\n      }\n    }\n  }\n\n  PathExpression(path: PathExpression): void {\n    const isInsideWith = this.withStack.length > 0\n    const isInsideEach = this.eachStack.length > 0\n    const rootVariable = path.original?.split(\".\")[0] ?? \"\"\n    const isBlockParam = this.currentBlockParams.has(rootVariable)\n    const isThisProperty = path.original.startsWith(\"this.\")\n\n    if (\n      !isInsideWith &&\n      !(isInsideEach && isThisProperty) && // Correctly ignore 'this.' prefixed variables inside 'each' blocks\n      !isBlockParam &&\n      !this.builtInHelpers.has(path.original)\n    ) {\n      this.variables.push(rootVariable) // Push rootVariable instead if you want to collect the base name\n    }\n  }\n}\n\nexport function extractVariablesForHandlebars(template: string): string[] {\n  try {\n    const ast = handlebars.parse(template)\n    const scanner = new VariableScanner()\n    scanner.accept(ast)\n    return scanner.variables\n  } catch (error) {\n    return []\n  }\n}\n","import type handlebars from \"@langtail/handlebars-evalless\"\nimport { format, parseISO } from \"date-fns\"\n\nconst isObject = function (val: any) {\n  return typeof val === \"object\"\n}\n\nconst isOptions = function (val: any) {\n  return isObject(val) && isObject(val.hash)\n}\nexport const defaultDateFormat = \"MMMM dd, yyyy\"\n\nconst formatDateSafe = function (date: Date, pattern: string) {\n  try {\n    return format(date, pattern)\n  } catch (e) {\n    return \"\"\n  }\n}\n\nexport function handlebarsDateHelper(\n  str: string | number | Date | null,\n  pattern: any,\n  options: any\n) {\n  if (isOptions(pattern)) {\n    options = pattern\n    pattern = null\n  }\n\n  if (isOptions(str)) {\n    options = str\n    pattern = null\n    str = null\n  }\n\n  // if no args are passed, return a formatted date\n  if (str == null && pattern == null) {\n    return formatDateSafe(new Date(), defaultDateFormat)\n  }\n\n  const date = str instanceof Date ? str : new Date(str as string | number)\n\n  // if both args are strings, this could apply to either lib.\n  if (typeof str === \"string\" && typeof pattern === \"string\") {\n    return formatDateSafe(parseISO(str), pattern)\n  }\n\n  // if only a string is passed, assume it's a date pattern ('YYYY')\n  if (typeof str === \"string\" && !pattern) {\n    return formatDateSafe(new Date(), str)\n  }\n\n  return formatDateSafe(date, pattern)\n}\n\nexport const operatorHelpers: handlebars.HelperDeclareSpec = {\n  eq: (v1, v2) => v1 == v2,\n  ne: (v1, v2) => v1 != v2,\n  lt: (v1, v2) => v1 < v2,\n  gt: (v1, v2) => v1 > v2,\n  lte: (v1, v2) => v1 <= v2,\n  gte: (v1, v2) => v1 >= v2,\n  and() {\n    return Array.prototype.every.call(arguments, Boolean)\n  },\n  or() {\n    return Array.prototype.slice.call(arguments, 0, -1).some(Boolean)\n  },\n}\n"],"mappings":"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","names":["import_zod","handlebars","queryString","OpenAI","options"]}