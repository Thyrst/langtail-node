{"version":3,"sources":["../src/template.ts","../src/handlebars-helpers.ts"],"sourcesContent":["import handlebars from \"@langtail/handlebars-evalless\"\nimport { Visitor } from \"handlebars\"\n\nimport { handlebarsDateHelper, operatorHelpers } from \"./handlebars-helpers\"\nimport { JSONValue } from \"./jsonType\"\nimport { ContentArray } from \"./schemas\"\n\nhandlebars.registerHelper(\"$date\", handlebarsDateHelper)\nhandlebars.registerHelper(operatorHelpers)\n\n/*\n * This class is used to wrap the input object to be used in handlebars templates. Without this JSON objects are rendered as [object Object]\n */\nclass TemplateObject {\n  _value: any\n  constructor(props: any) {\n    this._value = props\n  }\n  toString() {\n    return JSON.stringify(this._value, null, 2)\n  }\n}\n\nfunction castToTemplateObject(value: any): any {\n  if (typeof value === \"object\" && value !== null) {\n    if (Array.isArray(value)) {\n      return value.map((item) => castToTemplateObject(item))\n    }\n    return new TemplateObject(value)\n  }\n  return value\n}\n\n// does not throw\nexport const compileStringHandlebars = (\n  text: string,\n  input: Record<string, JSONValue>,\n): {\n  text: string\n  error: Error | null\n} => {\n  try {\n    // Preprocess the template to improve readability and consistency. This involves:\n    // 1. Removing newline characters before and after the {{else}} block.\n    // 2. Removing newline characters before closing block helpers (like '/if', '/unless', '/with').\n    const preprocessedText = text\n      .replace(/\\n?({{else}})\\n?/g, \"$1\") // Remove newline before and after {{else}}\n      .replace(/\\n({{\\/(if|unless|with)}})/g, \"$1\") // Remove newline before closing block helpers\n\n    const template = handlebars.compileAST(preprocessedText, { noEscape: true }) // regular compile cannot be used in cloudflare worker\n\n    const parsedInput: Record<string, JSONValue | TemplateObject> = {}\n    for (const key in input) {\n      try {\n        const parsed = JSON.parse(input[key] as string)\n\n        if (typeof parsed === \"object\" && parsed !== null) {\n          if (Array.isArray(parsed)) {\n            parsedInput[key] = parsed.map((item) => castToTemplateObject(item))\n          } else {\n            parsedInput[key] = new TemplateObject(parsed)\n          }\n        } else {\n          parsedInput[key] = input[key]\n        }\n      } catch {\n        parsedInput[key] = input[key]\n      }\n    }\n\n    const handlebarsOutput = template(parsedInput).replace(/\\n$/g, \"\") // Remove trailing newline,\n    return {\n      text: handlebarsOutput, // ideally we would not even encode it, but in handlebars HTML entities encoding cannot be turned off. We could only use triple curly braces\n      error: null,\n    }\n  } catch (err: any) {\n    return { text, error: err }\n  }\n}\n\nexport const compileLTTemplate = (\n  content: string | ContentArray | null,\n  input: Record<string, string>,\n) => {\n  if (content === null) {\n    return null\n  }\n\n  if (typeof content === \"string\") {\n    return compileStringHandlebars(content, input).text\n  }\n\n  return content.map((item) => {\n    if (item.type === \"text\") {\n      return { ...item, text: compileStringHandlebars(item.text, input).text }\n    }\n    return item\n  })\n}\n\ninterface PathExpression {\n  original: string\n}\n\nclass VariableScanner extends Visitor {\n  variables: string[]\n  builtInHelpers: Set<string>\n  withStack: boolean[] // Track 'with' blocks depth\n  eachStack: boolean[] // Track 'each' blocks depth\n  currentBlockParams: Set<string> // Track block params for 'each' blocks\n\n  constructor() {\n    super()\n    this.variables = []\n    this.builtInHelpers = new Set([\n      \"if\",\n      \"each\",\n      \"unless\",\n      \"with\",\n      \"log\",\n      \"lookup\",\n      \"this\",\n      \"blockHelperMissing\",\n      \"helperMissing\",\n      \"raw\",\n      \"eq\",\n      \"ne\",\n      \"lt\",\n      \"gt\",\n      \"lte\",\n      \"gte\",\n      \"and\",\n      \"or\",\n      \"@key\",\n      \"@index\",\n      \"$date\",\n    ])\n    this.withStack = []\n    this.eachStack = []\n    this.currentBlockParams = new Set()\n  }\n\n  BlockStatement(block: any): void {\n    // Check for 'with' and 'each' blocks\n    const isWithBlock = block.path.original === \"with\"\n    const isEachBlock = block.path.original === \"each\"\n\n    if (isWithBlock) {\n      this.withStack.push(true)\n      if (\n        block.params[0] &&\n        !this.builtInHelpers.has(block.params[0].original)\n      ) {\n        this.variables.push(block.params[0].original)\n      }\n    }\n\n    if (isEachBlock) {\n      this.eachStack.push(true) // Indicate we're inside an 'each' block\n      if (block.program.blockParams?.length > 0) {\n        block.program.blockParams.forEach((param: any) =>\n          this.currentBlockParams.add(param),\n        )\n      }\n    }\n\n    // Process the block's content\n    super.BlockStatement(block)\n\n    if (isWithBlock) {\n      this.withStack.pop()\n    }\n\n    if (isEachBlock) {\n      this.eachStack.pop() // Exiting the 'each' block\n      if (block.program.blockParams?.length > 0) {\n        block.program.blockParams.forEach((param: any) =>\n          this.currentBlockParams.delete(param),\n        )\n      }\n    }\n  }\n\n  PathExpression(path: PathExpression): void {\n    const isInsideWith = this.withStack.length > 0\n    const isInsideEach = this.eachStack.length > 0\n    const rootVariable = path.original?.split(\".\")[0] ?? \"\"\n    const isBlockParam = this.currentBlockParams.has(rootVariable)\n    const isThisProperty = path.original.startsWith(\"this.\")\n\n    if (\n      !isInsideWith &&\n      !(isInsideEach && isThisProperty) && // Correctly ignore 'this.' prefixed variables inside 'each' blocks\n      !isBlockParam &&\n      !this.builtInHelpers.has(path.original)\n    ) {\n      this.variables.push(rootVariable) // Push rootVariable instead if you want to collect the base name\n    }\n  }\n}\n\nexport function extractVariablesForHandlebars(template: string): string[] {\n  try {\n    const ast = handlebars.parse(template)\n    const scanner = new VariableScanner()\n    scanner.accept(ast)\n    return scanner.variables\n  } catch (error) {\n    return []\n  }\n}\n","import type handlebars from \"@langtail/handlebars-evalless\"\nimport { format, parseISO } from \"date-fns\"\n\nconst isObject = function (val: any) {\n  return typeof val === \"object\"\n}\n\nconst isOptions = function (val: any) {\n  return isObject(val) && isObject(val.hash)\n}\nexport const defaultDateFormat = \"MMMM dd, yyyy\"\n\nconst formatDateSafe = function (date: Date, pattern: string) {\n  try {\n    return format(date, pattern)\n  } catch (e) {\n    return \"\"\n  }\n}\n\nexport function handlebarsDateHelper(\n  str: string | number | Date | null,\n  pattern: any,\n  options: any\n) {\n  if (isOptions(pattern)) {\n    options = pattern\n    pattern = null\n  }\n\n  if (isOptions(str)) {\n    options = str\n    pattern = null\n    str = null\n  }\n\n  // if no args are passed, return a formatted date\n  if (str == null && pattern == null) {\n    return formatDateSafe(new Date(), defaultDateFormat)\n  }\n\n  const date = str instanceof Date ? str : new Date(str as string | number)\n\n  // if both args are strings, this could apply to either lib.\n  if (typeof str === \"string\" && typeof pattern === \"string\") {\n    return formatDateSafe(parseISO(str), pattern)\n  }\n\n  // if only a string is passed, assume it's a date pattern ('YYYY')\n  if (typeof str === \"string\" && !pattern) {\n    return formatDateSafe(new Date(), str)\n  }\n\n  return formatDateSafe(date, pattern)\n}\n\nexport const operatorHelpers: handlebars.HelperDeclareSpec = {\n  eq: (v1, v2) => v1 == v2,\n  ne: (v1, v2) => v1 != v2,\n  lt: (v1, v2) => v1 < v2,\n  gt: (v1, v2) => v1 > v2,\n  lte: (v1, v2) => v1 <= v2,\n  gte: (v1, v2) => v1 >= v2,\n  and() {\n    return Array.prototype.every.call(arguments, Boolean)\n  },\n  or() {\n    return Array.prototype.slice.call(arguments, 0, -1).some(Boolean)\n  },\n}\n"],"mappings":"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","names":[]}